/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.4.1 public/texturedHand.glb --types --output src/3DModels/texHand.tsx 
*/

import * as THREE from "three";
import React, {
  MutableRefObject,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { glReady } from "@/ts/atoms";
import { useAtom } from "jotai";
import { useSearchParams } from "next/navigation";
import { useRouter } from "next/router";
import {
  Color,
  Mesh,
  MeshStandardMaterial,
  ShaderMaterial,
  Texture,
  Vector2,
  Vector3,
} from "three";
import { lerp } from "three/src/math/MathUtils.js";
import { useFrame } from "@react-three/fiber";

const t = {
  type: "spring",
  damping: 30,
  stiffness: 55,
  restDelta: 0.001,
};

const handVariants = {
  initial: { scale: 0.5, y: -1 },
  focus: { scale: 0.9, y: 0.9 },
  enter: { scale: 1, y: 0.65 },
};
const vertexShader = `
varying vec3 vPosition;
varying vec3 vNormal;

void main() {
    vNormal = normal;
    vPosition = position;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;

const fragmentShader = `
uniform float opacity;
uniform vec3 uCameraPosition;
uniform vec3 uLightDirection1;
uniform vec3 uLightDirection2;

varying vec3 vPosition;
varying vec3 vNormal;

void main() {
    vec3 viewDir = normalize(uCameraPosition - vPosition);

    float diffuse1 = dot(normalize(vNormal), -uLightDirection1);
    diffuse1 = clamp(diffuse1, 0.0, 1.0);

    float diffuse2 = dot(normalize(vNormal), -uLightDirection2);
    diffuse2 = clamp(diffuse2, 0.0, 0.5);

    float diffuse = max(diffuse1, diffuse2);

    vec3 sphereCenter = vec3(0.7, 0.0, -1.4);
    float sphereRadius = 1.6;
    float sphereFalloff = 0.3;
    float distance = length(vPosition - sphereCenter);
    float sphereFade = smoothstep(sphereRadius - sphereFalloff, sphereRadius + sphereFalloff, distance);
    float invertedMask = 1.0 - sphereFade;

    float rim = dot(normalize(vNormal), viewDir);
    rim = clamp(1.0 - abs(rim), 0.0, 1.0);

    // Alpha ist gleich 1.0 f√ºr depth testing, eigentliche Deckkraft wird immer von color.alpha bestimmt
    float depthAlpha = 1.0;
    float visualAlpha = rim * invertedMask * diffuse * opacity;

    vec3 color = vec3(0.918, 1.0, 0.714);

    gl_FragColor = vec4(color, depthAlpha);
    gl_FragColor.a = visualAlpha;
}

`;

type GLTFResult = GLTF & {
  nodes: {
    Shape_IndexedFaceSet001: THREE.SkinnedMesh;
    Bone: THREE.Bone;
    Bone001: THREE.Bone;
    Bone002: THREE.Bone;
    Bone003: THREE.Bone;
    Bone004: THREE.Bone;
    Bone017: THREE.Bone;
  };
  materials: {
    Arms__Standard_: THREE.MeshStandardMaterial;
  };
  animations: any[];
};

type HandProps = {
  scroll: MutableRefObject<number>;
  useCustomShader?: boolean;
  props?: JSX.IntrinsicElements["group"];
};

export function ShaderHand({
  scroll,
  useCustomShader = true,
  ...props
}: HandProps) {
  const { nodes, materials } = useGLTF("/texturedHand.glb") as GLTFResult;
  const shaderRef = useRef<ShaderMaterial>(null);
  const [shaderCompiled, setShaderCompiled] = useAtom(glReady);
  const router = useRouter();
  const searchParams = useSearchParams();
  const [disposed, setDisposed] = useState(true);

  useEffect(() => {
    router.pathname === "/"
      ? setTimeout(() => {
        setDisposed(false);
      }, 200)
      : setDisposed(true);
  }, [router.pathname]);

  const handleShaderCompiled = () => {
    setShaderCompiled(true);
  };

  const uniforms = useMemo(
    () => ({
      opacity: { value: 0.0 },
      uCameraPosition: { value: new Vector3(0, 1.5, 30) },
      uLightDirection1: { value: new Vector3(-20, 5, -15) },
      uLightDirection2: { value: new Vector3(-18, -20, 15) },
    }),
    []
  );

  useFrame(() => {
    if (shaderRef.current) {
      const targetOpacity =
        router.pathname === "/"
          ? scroll.current > 0.015
            ? 0
            : 1
          : router.pathname === "/einsatzgebiete" &&
            searchParams.get("focusGroup")
            ? 1
            : 0;
      uniforms.opacity.value = lerp(uniforms.opacity.value, targetOpacity, 0.1);
      shaderRef.current.needsUpdate = true;
    }
  });

  return (
    <group
      visible={!disposed}
      scale={1}
      position={[0.6, 0.6, 0.15]}
      rotation={[Math.PI / -0.99, 1.9, 0]}
      {...props}
      dispose={null}
    >
      <mesh geometry={nodes.Shape_IndexedFaceSet001.geometry}>
        <shaderMaterial
          attach="material"
          ref={shaderRef}
          uniforms={uniforms}
          fragmentShader={fragmentShader}
          vertexShader={vertexShader}
          transparent
          depthTest
          depthWrite
          onBeforeCompile={handleShaderCompiled}
        />
      </mesh>
    </group>
  );
}

useGLTF.preload("/texturedHand.glb");

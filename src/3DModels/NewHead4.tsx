/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 public/newHead.glb --types --output src/NewHead.tsx 
*/

import React, {
  MutableRefObject,
  Suspense,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import {
  Float,
  MeshTransmissionMaterial,
  useAspect,
  useGLTF,
} from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { motion as motion3d } from "framer-motion-3d";
import { useFrame, useThree } from "@react-three/fiber";
import { useAtom } from "jotai";
import { useRouter } from "next/router";
import { useAnimation } from "framer-motion";
import { useSearchParams } from "next/navigation";
import { SkinnedMesh } from "three/src/objects/SkinnedMesh.js";
import { Bone } from "three/src/objects/Bone.js";
import { Model } from "./GhostHand";
import { Mesh } from "three/src/objects/Mesh.js";
import { size as s } from "../ts/utils";
import { extend } from "@react-three/fiber";
import { productViewer, globalTarget, orbitTarget, loc } from "@/ts/atoms";
import IdeaCloud from "@/ts/landingGL/IdeaCloud";
import { ShaderHand } from "./texHand";
import { TexturedHand } from "./texHand2";
import WordCloud from "@/ts/brainBasicsGL/WordCloud";
import Camouflage, {
  CamouflageShaderMaterial,
} from "@/ts/brainBasicsGL/Camouflage";
import { AdditiveBlending, Group, MathUtils, Vector2, Vector3 } from "three";
import * as BufferGeometryUtils from "@/ts/threeExport/BufferGeometryUtils"
import { LRBrain } from "./LRBrain";
import { lerp } from "three/src/math/MathUtils.js";


const GoldShader = (
  <shaderMaterial
    uniforms={{
      uTime: { value: 0.0 },
      uResolution: { value: new Vector2() },
      uCameraPosition: { value: new Vector3() },
    }}
    vertexShader={`
    varying vec3 vNormal;
    varying vec3 vPosition;
    void main() {
      vNormal = normalize(normalMatrix * normal);
      vPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `}
    fragmentShader={`
    uniform vec3 uCameraPosition;
    varying vec3 vNormal;
    varying vec3 vPosition;
    
    void main() {
      vec3 viewDir = normalize(uCameraPosition - vPosition);
      vec3 reflectDir = reflect(viewDir, normalize(vNormal));
      
      vec3 baseColor = vec3(1.0, 0.64, 0.0);
      vec3 ambient = 0.2 * baseColor;
      vec3 diffuse = 0.8 * baseColor * max(dot(normalize(vNormal), normalize(viewDir)), 0.0);
      vec3 specular = vec3(1.0) * pow(max(dot(viewDir, reflectDir), 0.0), 32.0);

      gl_FragColor = vec4(ambient + diffuse + specular, 1.0);
    }
  `}
  />
);

extend({ GoldShader });

export default GoldShader;

type GLTFResult = GLTF & {
  nodes: {

    stem: Mesh;

  };
  materials: {};
  animations: any[];
};

type HeadHandsProps = {
  scroll: MutableRefObject<number>;
  props?: JSX.IntrinsicElements["group"];
};

const brainVariants = {
  initial: { scale: 0 },
  focus: { scale: 0.1 },
  enter: { scale: 1 },
  exit: { scale: 0 },
};

const material2Variants = {
  initial: { opacity: 0 },
  hidden: { opacity: 0 },
  hide: { opacity: 0.1 },
  enter: {
    opacity: 1,
    transition: {
      type: "spring",
      damping: 10,
      stiffness: 50,
      restDelta: 0.1,
      delay: 0.5,
    },
  },
  exit: {
    opacity: 0,
    transition: {
      type: "spring",
      damping: 10,
      stiffness: 50,
      restDelta: 0.1,
      delay: 0.25,
    },
  },
};

const words = [
  "Think",
  "Act",
  "Move",
  "Motivation",
  "Satisfaction",
  "Flexible",
  "Exzellenz",
  "Kreativität",
  "Entscheiden",
  "Problemlösung",
  "Adaptability",
  "Fokus",
  "Resilienz",
  "Kollaboration",
  "Courage",
  "Engagement",
  "Effizienz",
  "Productivity",
];
const colors = [
  "#92a9c5",
  "#f4f9ff",
  "#ffffff",
  "#c6dfe8",
  "#f4e4ad",
  "#f0f7ff",
  "#e7f1ff",
  "#eeeac9",
  "#ecf8ff",
  "#f8f1cd",
  "#b1cef0",
  "#e8ce86",
  "#dde5f0",
  "#fffdec",
  "#bed0ef",
  "#cfdff0",
];



export function NewHead4(props: HeadHandsProps) {
  const { nodes, materials } = useGLTF("/highrez_brain.glb") as GLTFResult;
  const [pvAtom, setPVAtom] = useAtom(productViewer);
  const [gTarget, setGTarget] = useAtom(globalTarget);
  const [target, setTarget] = useAtom(orbitTarget);
  const [app, setApp] = useAtom(loc);
  const [pos, setPos] = useState<any>([]);
  const [scl, setScale] = useState<any>([]);
  const { viewport, size } = useThree();
  const [w, h] = useAspect(size.width, size.height);
  const router = useRouter();

  //refs
  const group = useRef<Group>(null);
  const [location, setLocation] = useAtom(loc);

  //searchParams
  const searchParams = useSearchParams();

  // refs
  const brain = useRef<any>(!null);

  // animation controls
  const controls = useAnimation();
  const hand1_controls = useAnimation();
  const brain_material_controls = useAnimation();

  // states
  const [brainDisposed, setBDisposed] = useState(false);
  const [headDisposed, setHDisposed] = useState(false);
  const [hand1Disposed, setH1Disposed] = useState(false);
  const [hand2Disposed, setH2Disposed] = useState(false);
  const [isInPage, setIsInPage] = useState(false);
  const [disposed, setDisposed] = useState(false);

  useEffect(() => {
    const scale: any = [
      (pvAtom?.width / window.innerWidth) * viewport?.width,
      (pvAtom?.height / window.innerHeight) * viewport?.height,
      1,
    ];
    const position: any = [
      ((pvAtom?.width / window.innerWidth) * viewport.width) / 2 -
      viewport.width / 2 +
      (pvAtom?.left / window.innerWidth) * viewport.width,
      -s(11, viewport.width / 1.35, 14) -
      ((pvAtom?.height / window.innerHeight) * viewport.height) / 2 +
      viewport.height / 2 -
      (pvAtom?.top / window.innerHeight) * viewport.height,
      0,
    ];
    setPos(position);
    setScale(scale);
  }, [pvAtom]);

  const hand2Material = (
    <motion3d.meshStandardMaterial
      color="#dfa286"
      initial="initial"
      animate={controls}
      exit="exit"
      variants={material2Variants}
      transparent
      toneMapped
    />
  );

  const bmRef = useRef<any>(!null);
  const glassRef = useRef<any>(!null);



  const glass_material = (
    <MeshTransmissionMaterial
      ref={glassRef}
      samples={8}
      reflectivity={0}
      sheenRoughness={0}
      ior={1}
      iridescence={0.2}
      iridescenceIOR={0.6}
      resolution={512 * 2}
      thickness={0.05}
      anisotropy={0.5}
      anisotropicBlur={0.4}
      clearcoat={1}
      clearcoatRoughness={0.1}
      transparent
      opacity={0.1}
      color="#8fc8e6"
      roughness={0}
      chromaticAberration={0.1}
    />
  );

  const brain_mesh_controls = useAnimation();

  useFrame(() => {
    if (group.current) {
      group.current.position.x = lerp(group.current.position.x, pos[0], 0.045)
      group.current.position.y = lerp(group.current.position.y, pos[1], 0.045)
      group.current.position.z = lerp(group.current.position.z, pos[2], 0.045)
    }
    if (glassRef.current && router.pathname === "/business") {
      glassRef.current.opacity = lerp(glassRef.current.opacity, router.pathname === "/business" ? 1 : 0, 0.15)
    }
  })

  // enter animations

  useEffect(() => {
    if (router.pathname === "/") {
      if (props.scroll.current > 0.015) {
        brain_material_controls.start("hidden").then(() => {
          setIsInPage(false), setDisposed(true);
        });
      } else {
        setDisposed(false);
        setIsInPage(true);
        brain_mesh_controls.start("enter");
        brain_material_controls.start("enter");
      }
    } else if (router.pathname === "/einsatzgebiete") {
      if (searchParams.get("view") && !searchParams.get("focusGroup")) {
        brain_material_controls.start("hide");
      } else if (searchParams.get("view") && searchParams.get("focusGroup")) {
        brain_material_controls.start("hidden").then(() => {
          setIsInPage(false), setDisposed(true);
        });
      } else {
        setDisposed(false);
        setIsInPage(true);
        brain_mesh_controls.start("enter");
        brain_material_controls.start("enter");
      }
    } else if (router.pathname === "/business") {
      setDisposed(false);
      setIsInPage(true);
      brain_mesh_controls.start("enter");
      brain_material_controls.start("enter");

    } else {
      brain_material_controls.start("hidden").then(() => {
        setIsInPage(false), setDisposed(true);
      });
    }
  }, [router.pathname, props.scroll.current, searchParams]);

  const brain_material = (
    <motion3d.meshStandardMaterial
      ref={bmRef}
      initial="initial"
      animate={brain_material_controls}
      exit="exit"
      variants={material2Variants}
      color="#ffe1a0"
      metalness={1}
      roughness={0.1}
      toneMapped
    />
  );

  const mat = router.pathname === "/business" ? glass_material : brain_material;



  return (
    <group
      {...props}
      ref={group}
      position={pos}
      dispose={null}
      scale={s(7, scl[0] * s(0.5, viewport.width / 30, 0.8), 10)}
      rotation={[0, -Math.PI / 1.15, 0]}
    >
      <group rotation={[0, -0.3, 0]} scale={1}>
        {/* <Model scroll={props.scroll} /> */}
        <LRBrain position={[1, 0, 0]} />
        <ShaderHand scroll={props.scroll} />
        <TexturedHand />
        {/* <Camouflage colors={colors} /> */}
        {/* <skinnedMesh geometry={nodes.Shape_IndexedFaceSet001.geometry} material={nodes.Shape_IndexedFaceSet001.material} skeleton={nodes.Shape_IndexedFaceSet001.skeleton} >{MyShaderMaterial}</skinnedMesh> */}
      </group>
      <Float floatIntensity={0.1} rotationIntensity={0.1}>

        <group
          scale={1}
          rotation={[0, -Math.PI / 0.85, 0]}
          position={[0.075, -0.6, 0.1]}
        >
          <WordCloud
            active={router.pathname === "/business"}
            words={words}
            colors={colors}
          />
          <motion3d.group
            variants={brainVariants}
            initial="initial"
            animate={brain_mesh_controls}
            visible={!disposed}
          >
            <pointLight
              intensity={15}
              color={"#ffde5b"}
              position={[0.2, 1.5, 0]}
            />
            <mesh
              geometry={nodes.stem.geometry}
              position={[0, 1.7, -0.05]}
            >
              {mat}
            </mesh>

          </motion3d.group>
          <Suspense fallback={null}>
            <group position={[0.115, 1.9, 0]} scale={0.25}>
              <IdeaCloud scroll={props.scroll} centerPoint={[0, 0, 0]} />
            </group>
          </Suspense>
        </group>
      </Float>
    </group>
  );
}

// useGLTF.preload('/newHead4.glb')

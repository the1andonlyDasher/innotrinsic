/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 public/newHead.glb --types --output src/NewHead.tsx 
*/

import React, { MutableRefObject, Suspense, useEffect, useRef, useState } from 'react'
import { Float, MeshTransmissionMaterial, useAspect, useGLTF } from '@react-three/drei'
import { GLTF } from 'three-stdlib'
import { motion as motion3d } from "framer-motion-3d"
import { useThree } from '@react-three/fiber'
import { useAtom } from 'jotai'
import { useRouter } from 'next/router'
import { useAnimation } from 'framer-motion'
import { useSearchParams } from 'next/navigation'
import { SkinnedMesh } from 'three/src/objects/SkinnedMesh.js'
import { Bone } from 'three/src/objects/Bone.js'
import { Model } from './GhostHand'
import { Mesh } from 'three/src/objects/Mesh.js'
import { size as s } from "../ts/utils"
import * as THREE from 'three';
import { extend } from '@react-three/fiber';
import { productViewer, globalTarget, orbitTarget, loc } from '@/ts/atoms'
import IdeaCloud from '@/ts/landingGL/IdeaCloud'

const GoldShader = <shaderMaterial
  uniforms={{
    uTime: { value: 0.0 },
    uResolution: { value: new THREE.Vector2() },
    uCameraPosition: { value: new THREE.Vector3() },
  }}
  vertexShader={`
    varying vec3 vNormal;
    varying vec3 vPosition;
    void main() {
      vNormal = normalize(normalMatrix * normal);
      vPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `}
  fragmentShader={`
    uniform vec3 uCameraPosition;
    varying vec3 vNormal;
    varying vec3 vPosition;
    
    void main() {
      vec3 viewDir = normalize(uCameraPosition - vPosition);
      vec3 reflectDir = reflect(viewDir, normalize(vNormal));
      
      vec3 baseColor = vec3(1.0, 0.64, 0.0);
      vec3 ambient = 0.2 * baseColor;
      vec3 diffuse = 0.8 * baseColor * max(dot(normalize(vNormal), normalize(viewDir)), 0.0);
      vec3 specular = vec3(1.0) * pow(max(dot(viewDir, reflectDir), 0.0), 32.0);

      gl_FragColor = vec4(ambient + diffuse + specular, 1.0);
    }
  `}
/>;

extend({ GoldShader });

export default GoldShader;


type GLTFResult = GLTF & {
  nodes: {
    Shape_IndexedFaceSet001: SkinnedMesh
    base: Mesh
    right_hemisphere: Mesh
    left_hemisphere: Mesh
    cerebellum: Mesh
    stem: Mesh
    BezierCurve: Mesh
    Bone: Bone
  }
  materials: {}
  animations: any[]
}


type HeadHandsProps = {
  scroll: MutableRefObject<number>;
  props?: JSX.IntrinsicElements["group"];

};

const brainVariants = {
  initial: { scale: 0 },
  focus: { scale: 0.1 },
  enter: { scale: 1 },
  exit: { scale: 0 }
}

const material2Variants = {
  initial: { opacity: 0 },
  hidden: { opacity: 0 },
  hide: { opacity: 0.1 },
  enter: {
    opacity: 1,
    transition: {
      type: "spring",
      damping: 10,
      stiffness: 50,
      restDelta: 0.1,
      delay: 0.5
    },
  },
  exit: {
    opacity: 0,
    transition: {
      type: "spring",
      damping: 10,
      stiffness: 50,
      restDelta: 0.1,
      delay: 0.25,
    },
  },
};

export function NewHead4(props: HeadHandsProps) {
  const { nodes, materials } = useGLTF('/newHead4.glb') as GLTFResult
  const [pvAtom, setPVAtom] = useAtom(productViewer);
  const [gTarget, setGTarget] = useAtom(globalTarget);
  const [target, setTarget] = useAtom(orbitTarget);
  const [app, setApp] = useAtom(loc);
  const [pos, setPos] = useState<any>([]);
  const [scl, setScale] = useState<any>([]);
  const { viewport, size } = useThree();
  const [w, h] = useAspect(size.width, size.height);
  const router = useRouter();

  //refs
  const group: any = useRef(!null);
  const [location, setLocation] = useAtom(loc);

  //searchParams
  const searchParams = useSearchParams();

  // refs
  const brain = useRef<any>(!null);

  // animation controls
  const controls = useAnimation();
  const hand1_controls = useAnimation();
  const brain_material_controls = useAnimation();


  // states
  const [brainDisposed, setBDisposed] = useState(false);
  const [headDisposed, setHDisposed] = useState(false);
  const [hand1Disposed, setH1Disposed] = useState(false);
  const [hand2Disposed, setH2Disposed] = useState(false);
  const [isInPage, setIsInPage] = useState(false);
  const [disposed, setDisposed] = useState(false);


  useEffect(() => {
    const scale: any = [
      (pvAtom?.width / window.innerWidth) * viewport?.width,
      (pvAtom?.height / window.innerHeight) * viewport?.height,
      1,
    ];
    const position: any = [
      ((pvAtom?.width / window.innerWidth) * viewport.width) / 2 -
      viewport.width / 2 +
      (pvAtom?.left / window.innerWidth) * viewport.width,
      -s(7.5, viewport.width / 1.3, 14) -
      ((pvAtom?.height / window.innerHeight) * viewport.height) / 2 +
      viewport.height / 2 -
      (pvAtom?.top / window.innerHeight) * viewport.height,
      0,
    ];
    setPos(position);
    setScale(scale);
  }, [pvAtom]);

  const hand2Material = (
    <motion3d.meshStandardMaterial
      color="#dfa286"
      initial="initial"
      animate={controls}
      exit="exit"
      variants={material2Variants}
      transparent
      toneMapped
    />
  );

  const bmRef = useRef<any>(!null);
  const brain_material = (
    <motion3d.meshStandardMaterial
      ref={bmRef}
      initial="initial"
      animate={brain_material_controls}
      exit="exit"
      variants={material2Variants}
      color="#ffe1a0"
      metalness={1}
      roughness={0.1}
      toneMapped
    />
  );

  const glass_material = (
    <MeshTransmissionMaterial
      samples={8}
      reflectivity={0.85}
      sheenRoughness={0}
      opacity={0.4}
      iridescence={0.5}
      iridescenceIOR={0.95}
      resolution={1024 * 2}
      thickness={0}
      anisotropy={0.75}
      anisotropicBlur={0.75}
      clearcoat={1}
      clearcoatRoughness={0}
      transparent
      color="#caf1a8"
      roughness={0}
      chromaticAberration={0.65}
    />
  );

  const brain_mesh_controls = useAnimation();

  useEffect(() => {
    if (router.pathname === "/") {
      if ((props.scroll.current > 0.015)) {
        brain_material_controls.start("hidden").then(() => {
          setIsInPage(false), setDisposed(true)
        });
      } else {
        setDisposed(false);
        setIsInPage(true);
      }
    } else if (router.pathname === "/einsatzgebiete") {
      if (searchParams.get("view") && !searchParams.get("focusGroup")) {
        brain_material_controls.start("hide")
      } else if (searchParams.get("view") && searchParams.get("focusGroup")) {
        brain_material_controls.start("hidden").then(() => {
          setIsInPage(false), setDisposed(true)
        });
      } else {
        brain_mesh_controls.start("enter")
        brain_material_controls.start("enter")
      }
    }
    else {
      brain_material_controls.start("hidden").then(() => {
        setIsInPage(false), setDisposed(true)
      });
    }
  }, [router.pathname, props.scroll.current, searchParams]);

  useEffect(() => {
    if (isInPage) {
      brain_mesh_controls.start("enter")
      brain_material_controls.start("enter")
    }
  }, [isInPage]);
  return (
    <group {...props}  {...props} position={pos} dispose={null} scale={s(5, scl[0] / 1.5, 10)} rotation={[0, -Math.PI / 1.15, 0]}>
      <group rotation={[0, -0.3, 0]} scale={1}>
        <primitive object={nodes.Bone} />
        <Model scroll={props.scroll} />
        {/* <skinnedMesh geometry={nodes.Shape_IndexedFaceSet001.geometry} material={nodes.Shape_IndexedFaceSet001.material} skeleton={nodes.Shape_IndexedFaceSet001.skeleton} >{MyShaderMaterial}</skinnedMesh> */}
      </group>
      <Float floatIntensity={0.1} rotationIntensity={0.1}>
        <group scale={1} rotation={[0, -Math.PI / 0.85, 0]} position={[0.075, -0.6, 0.1]}>
          <motion3d.group variants={brainVariants} initial="initial" animate={brain_mesh_controls} visible={!disposed}>
            <pointLight intensity={15} color={"#ffde5b"} position={[0.2, 1.5, 0]} />
            <mesh geometry={nodes.base.geometry} material={nodes.base.material} position={[0.137, 1.743, 0]} rotation={[Math.PI, 0, Math.PI]} scale={[0.337, 0.325, 0.308]} >{brain_material}</mesh>
            <mesh geometry={nodes.right_hemisphere.geometry} material={nodes.right_hemisphere.material} position={[0.137, 1.743, 0]} rotation={[Math.PI, 0, Math.PI]} scale={[0.337, 0.325, 0.308]} >{brain_material}</mesh>
            <mesh geometry={nodes.left_hemisphere.geometry} material={nodes.left_hemisphere.material} position={[0.137, 1.743, 0]} rotation={[-Math.PI, 0, 0]} scale={[-0.337, -0.325, -0.308]} >{brain_material}</mesh>
            <mesh geometry={nodes.cerebellum.geometry} material={nodes.cerebellum.material} position={[-0.066, 1.587, 0]} scale={[0.123, 0.061, 0.123]} >{brain_material}</mesh>
            <mesh geometry={nodes.stem.geometry} material={nodes.stem.material} position={[0.071, 1.561, 0]} scale={[0.083, 0.206, 0.083]} >{brain_material}</mesh>
            <mesh geometry={nodes.BezierCurve.geometry} material={nodes.BezierCurve.material} position={[0, 1.722, 0]} >{brain_material}</mesh>
          </motion3d.group>
          <Suspense fallback={null}>
            <group position={[0.115, 1.9, 0]} scale={0.25}>
              <IdeaCloud scroll={props.scroll} centerPoint={[0, 0, 0]} />
            </group>
          </Suspense>
        </group>
      </Float>
    </group>
  )
}

// useGLTF.preload('/newHead4.glb')

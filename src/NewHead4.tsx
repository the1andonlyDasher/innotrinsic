/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 public/newHead.glb --types --output src/NewHead.tsx 
*/

import React, { MutableRefObject, useEffect, useRef, useState } from 'react'
import { Float, MeshTransmissionMaterial, useAspect, useGLTF } from '@react-three/drei'
import { GLTF } from 'three-stdlib'
import { motion as motion3d } from "framer-motion-3d"
import { useThree } from '@react-three/fiber'
import { useAtom } from 'jotai'
import { productViewer, globalTarget, orbitTarget, loc } from './ts/atoms'
import { size as s } from './ts/utils';
import { useRouter } from 'next/router'
import IdeaCloud from './ts/landingGL/IdeaCloud'
import { useAnimation } from 'framer-motion'
import { useSearchParams } from 'next/navigation'
import { SkinnedMesh } from 'three/src/objects/SkinnedMesh.js'
import { Bone } from 'three/src/objects/Bone.js'
import { AnimationClip } from './ts/threeExport/animation/AnimationClip'
import { Group } from 'three/src/objects/Group.js'

import { Model } from './GhostHand'
import { Mesh } from 'three/src/objects/Mesh.js'

// import { fragment, uniforms, vertex } from '../src/shaderData';

type GLTFResult = GLTF & {
  nodes: {
    Shape_IndexedFaceSet001: SkinnedMesh
    base: Mesh
    right_hemisphere: Mesh
    left_hemisphere: Mesh
    cerebellum: Mesh
    stem: Mesh
    BezierCurve: Mesh
    Bone: Bone
  }
  materials: {}
  animations: any[]
}


type HeadHandsProps = {
  scroll: MutableRefObject<number>;
  props?: JSX.IntrinsicElements["group"];
};



const material2Variants = {
  initial: { opacity: 0 },
  hidden: { opacity: 0 },
  hide: { opacity: 0.1 },
  enter: {
    opacity: 1,
    transition: {
      type: "spring",
      damping: 10,
      stiffness: 50,
      restDelta: 0.1,
      delay: 0.5
    },
  },
  exit: {
    opacity: 0,
    transition: {
      type: "spring",
      damping: 10,
      stiffness: 50,
      restDelta: 0.1,
      delay: 0.25,
    },
  },
};

type ContextType = Record<string, React.ForwardRefExoticComponent<JSX.IntrinsicElements['skinnedMesh'] | JSX.IntrinsicElements['mesh'] | JSX.IntrinsicElements['bone']>>

export function NewHead4(props: HeadHandsProps) {
  const { nodes, materials } = useGLTF('/newHead4.glb') as GLTFResult
  const [pvAtom, setPVAtom] = useAtom(productViewer);
  const [gTarget, setGTarget] = useAtom(globalTarget);
  const [target, setTarget] = useAtom(orbitTarget);
  const [app, setApp] = useAtom(loc);
  const [pos, setPos] = useState<any>([]);
  const [scl, setScale] = useState<any>([]);
  const { viewport, size } = useThree();
  const [w, h] = useAspect(size.width, size.height);
  const router = useRouter();

  //refs
  const group: any = useRef(!null);
  const [location, setLocation] = useAtom(loc);

  //searchParams
  const searchParams = useSearchParams();

  // refs
  const brain = useRef<any>(!null);

  // animation controls
  const controls = useAnimation();
  const hand1_controls = useAnimation();
  const brain_material_controls = useAnimation();


  // states

  const [brainDisposed, setBDisposed] = useState(false);
  const [headDisposed, setHDisposed] = useState(false);
  const [hand1Disposed, setH1Disposed] = useState(false);
  const [hand2Disposed, setH2Disposed] = useState(false);
  const [isInPage, setIsInPage] = useState(false);
  const [disposed, setDisposed] = useState(false);


  useEffect(() => {
    const scale: any = [
      (pvAtom?.width / window.innerWidth) * viewport?.width,
      (pvAtom?.height / window.innerHeight) * viewport?.height,
      1,
    ];
    const position: any = [
      ((pvAtom?.width / window.innerWidth) * viewport.width) / 2 -
      viewport.width / 2 +
      (pvAtom?.left / window.innerWidth) * viewport.width,
      -s(6, viewport.width / 1.5, 11) -
      ((pvAtom?.height / window.innerHeight) * viewport.height) / 2 +
      viewport.height / 2 -
      (pvAtom?.top / window.innerHeight) * viewport.height,
      0,
    ];
    setPos(position);
    setScale(scale);
  }, [pvAtom]);

  const hand2Material = (
    <motion3d.meshStandardMaterial
      color="#dfa286"
      initial="initial"
      animate={controls}
      exit="exit"
      variants={material2Variants}

      transparent
      toneMapped
    />
  );

  const bmRef = useRef<any>(!null);
  const brain_material = (
    <motion3d.meshStandardMaterial
      ref={bmRef}
      initial="initial"
      animate={brain_material_controls}
      exit="exit"
      variants={material2Variants}
      color="#ffe1a0"
      metalness={1}
      roughness={0.1}
      toneMapped
    />
  );

  const glass_material = (
    <MeshTransmissionMaterial
      samples={8}
      reflectivity={0.85}
      sheenRoughness={0}
      opacity={0.4}
      iridescence={0.5}
      iridescenceIOR={0.95}
      resolution={1024 * 2}
      thickness={0}
      anisotropy={0.75}
      anisotropicBlur={0.75}
      clearcoat={1}
      clearcoatRoughness={0}
      transparent
      color="#caf1a8"
      roughness={0}
      chromaticAberration={0.65}
    />
  );



  useEffect(() => {
    if (router.pathname === "/") {
      if ((props.scroll.current > 0.1)) {
        brain_material_controls.start(
          "hidden");
        controls.start("exit").then(() => {
          setIsInPage(false), setDisposed(true)
        });
      } else {
        setDisposed(false)
        setIsInPage(true)
      }
    } else {
      brain_material_controls.start(
        "hidden");
      controls.start("exit").then(() => {
        setIsInPage(false), setDisposed(true)
      });
    }
  }, [router.pathname, props.scroll.current]);

  useEffect(() => {
    if (isInPage) {
      if ((props.scroll.current > 0.1)) {
        brain_material_controls.start(
          "hidden");
        controls.start("exit");
      } else {
        brain_material_controls.start("enter")
        controls.start("enter")
      }
    } else {
      brain_material_controls.start(
        "hidden");
      controls.start("exit");
    }
  }, [isInPage]);
  return (
    <group {...props} visible={!disposed} {...props} position={pos} dispose={null} scale={s(6, viewport.width / 2, 9)} rotation={[0, -Math.PI / 1.15, 0]}>
      <group rotation={[0, -0.3, 0]} scale={1}>
        <primitive object={nodes.Bone} />
        <Model scroll={props.scroll} />
        {/* <skinnedMesh geometry={nodes.Shape_IndexedFaceSet001.geometry} material={nodes.Shape_IndexedFaceSet001.material} skeleton={nodes.Shape_IndexedFaceSet001.skeleton} >{MyShaderMaterial}</skinnedMesh> */}
      </group>
      <Float floatIntensity={0.1} rotationIntensity={0.1}>
        <group scale={1} rotation={[0, -Math.PI / 0.85, 0]} position={[0.125, -0.6, 0]}>
          <pointLight intensity={15} color={"#ffde5b"} position={[0.2, 1.5, 0]} />
          <mesh geometry={nodes.base.geometry} material={nodes.base.material} position={[0.137, 1.743, 0]} rotation={[Math.PI, 0, Math.PI]} scale={[0.337, 0.325, 0.308]} >{brain_material}</mesh>
          <mesh geometry={nodes.right_hemisphere.geometry} material={nodes.right_hemisphere.material} position={[0.137, 1.743, 0]} rotation={[Math.PI, 0, Math.PI]} scale={[0.337, 0.325, 0.308]} >{brain_material}</mesh>
          <mesh geometry={nodes.left_hemisphere.geometry} material={nodes.left_hemisphere.material} position={[0.137, 1.743, 0]} rotation={[-Math.PI, 0, 0]} scale={[-0.337, -0.325, -0.308]} >{brain_material}</mesh>
          <mesh geometry={nodes.cerebellum.geometry} material={nodes.cerebellum.material} position={[-0.066, 1.587, 0]} scale={[0.123, 0.061, 0.123]} >{brain_material}</mesh>
          <mesh geometry={nodes.stem.geometry} material={nodes.stem.material} position={[0.071, 1.561, 0]} scale={[0.083, 0.206, 0.083]} >{brain_material}</mesh>
          <mesh geometry={nodes.BezierCurve.geometry} material={nodes.BezierCurve.material} position={[0, 1.722, 0]} >{brain_material}</mesh>
          <group position={[0.115, 1.9, 0]} scale={0.25}>
            <IdeaCloud scroll={props.scroll} centerPoint={[0, 0, 0]} />
          </group>
        </group>
      </Float>
    </group>
  )
}

useGLTF.preload('/newHead4.glb')

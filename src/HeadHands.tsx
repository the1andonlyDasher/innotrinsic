/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 public/handsNhead.glb --types --output src/HeadHands.tsx 
*/

import * as THREE from "three";
import React, { MutableRefObject, useEffect, useRef, useState } from "react";
import {
  useGLTF,
  useAnimations,
  MeshTransmissionMaterial,
} from "@react-three/drei";
import { GLTF } from "three-stdlib";
import IdeaCloud from "./ts/landingGL/IdeaCloud";
import { motion as motion3d } from "framer-motion-3d";
import { useFrame, useThree } from "@react-three/fiber";
import { useAnimation } from "framer-motion";
import { useAtom } from "jotai";
import { useSearchParams } from "next/navigation";
import router from "next/router";
import { globalScroll, load, loc } from "./ts/atoms";
import { lerp } from "./ts/threeExport/math/MathUtils";

type HeadHandsProps = {
  scroll: MutableRefObject<number>;
  props?: JSX.IntrinsicElements["group"];
};

type GLTFResult = GLTF & {
  nodes: {
    Cube: THREE.SkinnedMesh;
    Cube001: THREE.SkinnedMesh;
    Cube002: THREE.Mesh;
    female_head001: THREE.Mesh;
    Bone: THREE.Bone;
    Bone003: THREE.Bone;
    Bone006: THREE.Bone;
    Bone009: THREE.Bone;
    Bone012: THREE.Bone;
    Bone_1: THREE.Bone;
    Bone003_1: THREE.Bone;
    Bone006_1: THREE.Bone;
    Bone009_1: THREE.Bone;
    Bone012_1: THREE.Bone;
  };
  materials: {};
  animations: GLTFAction[];
};

type ActionName =
  | "Cube.002Action"
  | "female_head.001Action"
  | "ArmatureAction"
  | "Armature.001Action";
interface GLTFAction extends THREE.AnimationClip {
  name: ActionName;
}
type ContextType = Record<
  string,
  React.ForwardRefExoticComponent<
    | JSX.IntrinsicElements["skinnedMesh"]
    | JSX.IntrinsicElements["mesh"]
    | JSX.IntrinsicElements["bone"]
  >
>;

const materialVariants = {
  initial: { opacity: 0 },
  hide: { opacity: 0.1 },
  enter: {
    opacity: 0.5,
    transition: {
      type: "spring",
      damping: 10,
      stiffness: 50,
      restDelta: 0.1,
    },
  },
  exit: {
    opacity: 0,
    transition: {
      type: "spring",
      damping: 10,
      stiffness: 50,
      restDelta: 0.1,
      delay: 0.25,
    },
  },
};

const material2Variants = {
  initial: { opacity: 0 },
  hidden: { opacity: 0 },
  hide: { opacity: 0.1 },
  enter: {
    opacity: 1,
    transition: {
      type: "spring",
      damping: 10,
      stiffness: 50,
      restDelta: 0.1,
    },
  },
  exit: {
    opacity: 0,
    transition: {
      type: "spring",
      damping: 10,
      stiffness: 50,
      restDelta: 0.1,
      delay: 0.25,
    },
  },
};

const handVariants = {
  initial: { scale: 0, y: -10, rotateX: 1, rotateY: -1.5 },
  enter: {
    rotateX: 1,
    rotateY: -1.5,
    scale: 1,
    y: 0,
    transition: {
      type: "spring",
      stiffness: 50,
      damping: 20,
      restDelta: 0.001,
      delay: 1,
    },
  },
  exit: {
    rotateX: 1,
    rotateY: -1.5,
    scale: 0,
    y: -10,
    transition: {
      type: "spring",
      stiffness: 50,
      damping: 20,
      restDelta: 0.001,
    },
  },
};

export function HeadHands(props: HeadHandsProps) {
  const [gScroll, setGScroll] = useAtom(globalScroll);

  const group: any = useRef<THREE.Group>();
  // GLTF
  const { nodes, materials, animations } = useGLTF(
    "/handsNhead.glb"
  ) as GLTFResult;
  const { actions }: any = useAnimations(animations, group);
  //gloabl loader
  const [location, setLocation] = useAtom(loc);

  //searchParams
  const searchParams = useSearchParams();

  // refs
  const brain = useRef<any>(!null);

  // animation controls
  const controls = useAnimation();
  const hand1_controls = useAnimation();
  const brain_material_controls = useAnimation();

  // THREE helpers
  const { viewport } = useThree();

  // states

  const [brainDisposed, setBDisposed] = useState(false);
  const [headDisposed, setHDisposed] = useState(false);
  const [hand1Disposed, setH1Disposed] = useState(false);
  const [hand2Disposed, setH2Disposed] = useState(false);
  const [isInPage, setIsInPage] = useState(false);
  const [disposed, setDisposed] = useState(false);

  // materials
  const mat = (
    <motion3d.meshPhysicalMaterial
      initial="initial"
      animate={controls}
      exit="exit"
      roughness={0}
      clearcoat={1}
      ior={1}
      iridescence={0.2}
      reflectivity={1}
      variants={materialVariants}
      color="#F7FFF2"
      transparent
      toneMapped
    />
  );

  const hand1Material = (
    <motion3d.meshStandardMaterial
      initial="initial"
      animate={hand1_controls}
      exit="exit"
      variants={material2Variants}
      color="#EDDFAB"
      transparent
      toneMapped
    />
  );

  const hand2Material = (
    <motion3d.meshStandardMaterial
      initial="initial"
      animate={controls}
      exit="exit"
      variants={material2Variants}
      color="#EDDFAB"
      transparent
      toneMapped
    />
  );

  const bmRef = useRef<any>(!null);
  const brain_material = (
    <motion3d.meshStandardMaterial
      ref={bmRef}
      initial="initial"
      animate={brain_material_controls}
      exit="exit"
      variants={material2Variants}
      color="#87e727"
      opacity={1}
      transparent
      toneMapped
    />
  );

  const glassMat: any = useRef();
  const glass = (
    <MeshTransmissionMaterial
      ref={glassMat}
      samples={16}
      reflectivity={1}
      sheenRoughness={0.2}
      anisotropicBlur={0.5}
      iridescence={0.5}
      iridescenceIOR={1}
      resolution={1024}
      thickness={0.1}

      clearcoat={1}
      transparent
      color="#b7eba7"
      anisotropy={1}
      chromaticAberration={0.5}
    />
  );

  // UEF for mounting and visibility
  useEffect(() => {
    if (
      (router.pathname === "/einsatzgebiete" || router.pathname === "/")
      && (searchParams.get("test") === null ||
        false)
    ) {
      setTimeout(() => {
        setDisposed(false);
        setBDisposed(false);
        setHDisposed(false);
        setH1Disposed(true);
        setH2Disposed(true);
        setIsInPage(true);
      }, 100);
    } else if (
      (router.pathname === "/einsatzgebiete" || router.pathname === "/")
      && (searchParams.get("test") !== null ||
        false)
    ) {
      setTimeout(() => {
        setH1Disposed(false);
        setH2Disposed(false);
        setBDisposed(false);
      }, 500);
    } else {
      setTimeout(() => {
        brain_material_controls.start("exit");
        controls.start("exit").then(() => {
          setIsInPage(false), setDisposed(true);
        });
      }, 800);
    }
  }, [router.pathname, searchParams]);

  // useEffect(() => {
  //   console.log(gScroll)
  // }, [gScroll])



  //searchParams
  useEffect(() => {
    if (isInPage) {
      controls.start(searchParams.get("test") !== null ? "enter" : "exit");
      searchParams.get("test") === null &&
        brain_material_controls.start(
          searchParams.get("view") !== null ? "hide" : "enter"
        );
    } else if (searchParams.get("test") === null) {
      setTimeout(() => {
        setH1Disposed(true);
        setH2Disposed(true);
        setIsInPage(true);
      }, 500);
    }
  }, [searchParams, isInPage]);

  useEffect(() => {
    actions["Armature.001Action"].reset().fadeIn(0.5).play().paused = true;
    actions["ArmatureAction"].reset().fadeIn(0.5).play().paused = true;
  }, []);

  useEffect(() => {
    if ((router.pathname === "/einsatzgebiete" || router.pathname === "/")) {
      console.log(props.scroll.current.toFixed(1), "sc");
      brain_material_controls.start(
        props.scroll.current > 0.1 ? "hidden" : "enter"
      );
      hand1_controls.start(props.scroll.current > 0.15 ? "enter" : "exit");
    } else {
      brain_material_controls.start("exit")
    }
  }, [props.scroll.current, router.pathname]);

  useFrame((state) => {
    actions["Armature.001Action"].time = lerp(
      actions["Armature.001Action"].time,
      actions["Armature.001Action"].getClip().duration * props.scroll.current,
      0.025
    );
    actions["ArmatureAction"].time = lerp(
      actions["ArmatureAction"].time,
      actions["ArmatureAction"].getClip().duration * props.scroll.current,
      0.025
    );
    glassMat.current.roughness = lerp(
      glassMat.current.roughness,
      searchParams.get("view") ? 1 : 0,
      0.5
    );
    glassMat.current.opacity = lerp(
      glassMat.current.opacity,
      searchParams.get("view")
        ? 0.1
        : router.pathname !== "/einsatzgebiete" &&
          router.pathname !== "/" ||
          searchParams.get("test") !== null
          ? 0
          : 1,
      0.075
    );
    // if (searchParams.get("test") === null) { bmRef.current.opacity = lerp(bmRef.current.opacity, props.scroll.current > 0.1 ? 0 : 1, 0.5) }
    // bmRef.current.opacity = lerp(glassMat.current.opacity, searchParams.get("view") ? 0.1 : router.pathname !== "/" || searchParams.get("test") !== null ? 0 : 1,
    //   router.pathname !== "/" || searchParams.get("test") !== null ? 0.03 : 0.05);
  });

  return (
    <group visible={!disposed} ref={group} {...props} dispose={null}>
      <group
        name="Scene"
        rotation={[0, Math.PI / 1.25, 0]}
        position={[0, -3.5, 0]}
      >
        <motion3d.group
          visible={!hand1Disposed}
          name="Armature"
          position={[1.543, 1.806, 1.657]}
          rotation={[-0.512, -1.029, 0.123]}
          scale={0.634}
        >
          <primitive object={nodes.Bone} />
          <primitive object={nodes.Bone003} />
          <primitive object={nodes.Bone006} />
          <primitive object={nodes.Bone009} />
          <primitive object={nodes.Bone012} />
          <skinnedMesh
            name="Cube"
            geometry={nodes.Cube.geometry}
            skeleton={nodes.Cube.skeleton}
          >
            {hand1Material}
          </skinnedMesh>
        </motion3d.group>
        <motion3d.group
          visible={!hand2Disposed}
          name="Armature001"
          position={[-1.255, 2.806, 1.699]}
          rotation={[Math.PI / 2, 0, -1.613]}
          scale={-0.634}
        >
          <primitive object={nodes.Bone_1} />
          <primitive object={nodes.Bone003_1} />
          <primitive object={nodes.Bone006_1} />
          <primitive object={nodes.Bone009_1} />
          <primitive object={nodes.Bone012_1} />
          <skinnedMesh
            name="Cube001"
            geometry={nodes.Cube001.geometry}
            skeleton={nodes.Cube001.skeleton}
          >
            {hand2Material}
          </skinnedMesh>
        </motion3d.group>
        <motion3d.mesh
          ref={brain}
          renderOrder={4}
          geometry={nodes.Cube002.geometry}
          position={[0, -1.2, -0]}
          visible={!brainDisposed}
        >
          {brain_material}
        </motion3d.mesh>
        <motion3d.mesh
          renderOrder={5}
          geometry={nodes.female_head001.geometry}
          position={[0.2, 0.2, -0.45]}
          visible={!headDisposed}
        >
          {glass}
        </motion3d.mesh>
        <IdeaCloud centerPoint={[0, 3, 0]} />
      </group>
    </group>
  );
}

useGLTF.preload("/handsNhead.glb");

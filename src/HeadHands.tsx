/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 public/handsNhead.glb --types --output src/HeadHands.tsx 
*/

import * as THREE from 'three'
import React, { MutableRefObject, useEffect, useRef, useState } from 'react'
import { useGLTF, useAnimations, MeshTransmissionMaterial } from '@react-three/drei'
import { GLTF } from 'three-stdlib'
import IdeaCloud from './ts/landingGL/IdeaCloud'
import { motion as motion3d } from "framer-motion-3d"
import { useFrame, useThree } from '@react-three/fiber'
import { useAnimation } from 'framer-motion'
import { useAtom } from 'jotai'
import { useSearchParams } from 'next/navigation'
import router from 'next/router'
import { globalScroll, load } from './ts/atoms'
import { lerp } from './ts/threeExport/math/MathUtils'

type HeadHandsProps = {
  scroll: MutableRefObject<number>;
  props?: JSX.IntrinsicElements['group']
}

type GLTFResult = GLTF & {
  nodes: {
    Cube: THREE.SkinnedMesh
    Cube001: THREE.SkinnedMesh
    Cube002: THREE.Mesh
    female_head001: THREE.Mesh
    Bone: THREE.Bone
    Bone003: THREE.Bone
    Bone006: THREE.Bone
    Bone009: THREE.Bone
    Bone012: THREE.Bone
    Bone_1: THREE.Bone
    Bone003_1: THREE.Bone
    Bone006_1: THREE.Bone
    Bone009_1: THREE.Bone
    Bone012_1: THREE.Bone
  }
  materials: {}
  animations: GLTFAction[]
}

type ActionName = 'Cube.002Action' | 'female_head.001Action' | 'ArmatureAction' | 'Armature.001Action'
interface GLTFAction extends THREE.AnimationClip {
  name: ActionName
}
type ContextType = Record<string, React.ForwardRefExoticComponent<JSX.IntrinsicElements['skinnedMesh'] | JSX.IntrinsicElements['mesh'] | JSX.IntrinsicElements['bone']>>

const materialVariants = {
  initial: { opacity: 0 },
  hide: { opacity: 0.1 },
  enter: {
    opacity: 0.5,
    transition: {
      type: "spring",
      damping: 10,
      stiffness: 50,
      restDelta: 0.1,
    },
  },
  exit: {
    opacity: 0, transition: {
      type: "spring",
      damping: 10,
      stiffness: 50,
      restDelta: 0.1, delay: 0.25
    }
  },
};

const material2Variants = {
  initial: { opacity: 0 },
  hide: { opacity: 0.1 },
  enter: {
    opacity: 1,
    transition: {
      type: "spring",
      damping: 10,
      stiffness: 50,
      restDelta: 0.1,
    }
  },
  exit: {
    opacity: 0, transition: {
      type: "spring",
      damping: 10,
      stiffness: 50,
      restDelta: 0.1, delay: 0.25
    }
  },
};

const handVariants = {
  initial: { scale: 0, y: -10, rotateX: 1, rotateY: -1.5 },
  enter: { rotateX: 1, rotateY: -1.5, scale: 1, y: 0, transition: { type: "spring", stiffness: 50, damping: 20, restDelta: 0.001, delay: 1 } },
  exit: { rotateX: 1, rotateY: -1.5, scale: 0, y: -10, transition: { type: "spring", stiffness: 50, damping: 20, restDelta: 0.001, } },
}


export function HeadHands(props: HeadHandsProps) {
  const [gScroll, setGScroll] = useAtom(globalScroll)

  const group: any = useRef<THREE.Group>()
  // GLTF
  const { nodes, materials, animations } = useGLTF('/handsNhead.glb') as GLTFResult
  const { actions }: any = useAnimations(animations, group)
  //gloabl loader
  const [loaded, setLoaded] = useAtom(load)

  //searchParams
  const searchParams = useSearchParams();

  // refs
  const brain = useRef<any>(!null);

  // animation controls
  const controls = useAnimation();
  const hand1_controls = useAnimation();
  const brain_material_controls = useAnimation();

  // THREE helpers
  const { viewport } = useThree();

  // states
  const [disposed, setDisposed] = useState(false);
  const [brainDisposed, setBDisposed] = useState(false);
  const [headDisposed, setHDisposed] = useState(false);
  const [hand1Disposed, setH1Disposed] = useState(false);
  const [hand2Disposed, setH2Disposed] = useState(false);
  const [isInPage, setIsInPage] = useState(false);

  // materials
  const mat = (
    <motion3d.meshPhysicalMaterial
      initial="initial"
      animate={controls}
      exit="exit"
      roughness={0}
      clearcoat={1}
      ior={1}
      iridescence={0.2}
      reflectivity={1}
      variants={materialVariants}
      color="#F7FFF2"
      transparent
      toneMapped
    />
  );

  const hand1Material = (
    <motion3d.meshStandardMaterial
      initial="initial"
      animate={hand1_controls}
      exit="exit"
      variants={material2Variants}
      color="#EDDFAB"
      transparent
      toneMapped
    />
  );

  const hand2Material = (
    <motion3d.meshStandardMaterial
      initial="initial"
      animate={controls}
      exit="exit"
      variants={material2Variants}
      color="#EDDFAB"
      transparent
      toneMapped
    />
  );

  const bmRef = useRef<any>(!null)
  const brain_material = (
    <motion3d.meshStandardMaterial
      ref={bmRef}
      initial="initial"
      animate={brain_material_controls}
      exit="exit"
      variants={material2Variants}
      color="#87e727"
      opacity={1}
      transparent
      toneMapped
    />
  );

  const glassMat: any = useRef()
  const glass = <MeshTransmissionMaterial
    ref={glassMat}
    samples={16}
    reflectivity={1}
    sheenRoughness={0.2}
    anisotropicBlur={0.1}
    iridescence={1}
    iridescenceIOR={1}
    resolution={2048}
    thickness={0.1}
    roughness={0.1}
    clearcoat={1}
    transparent
    color="#E5F9A9"
    anisotropy={1}
    chromaticAberration={0.5} />

  // UEF for mounting and visibility
  useEffect(() => {
    if (router.pathname === "/" && searchParams.get("test") === null || false) {
      setTimeout(() => {
        setDisposed(false);
        setBDisposed(false);
        setHDisposed(false);
        setH1Disposed(true);
        setH2Disposed(true);
        setIsInPage(true);
      }, 1000);
    } else if (router.pathname === "/" && searchParams.get("test") !== null || false) {
      setTimeout(() => {
        setH1Disposed(false);
        setH2Disposed(false);
        setBDisposed(false);
      }, 500);
    } else {
      setTimeout(() => {
        brain_material_controls.start("exit")
        controls.start("exit").then(() => {
          setIsInPage(false), setDisposed(true);
        });
      }, 800)

    }
  }, [router.pathname, searchParams]);

  // useEffect(() => {
  //   console.log(gScroll)
  // }, [gScroll])

  useEffect(() => {
    if (isInPage) {

    }
  }, [isInPage]);

  //searchParams
  useEffect(() => {
    if (isInPage) {
      controls.start(searchParams.get("test") !== null ? "enter" : "exit");
      searchParams.get("test") === null && brain_material_controls.start(searchParams.get("view") !== null ? "hide" : "enter");
    }
    else if (searchParams.get("test") === null) {
      setTimeout(() => {
        setH1Disposed(true);
        setH2Disposed(true);
        setIsInPage(true);
      }, 500);
    }
  }, [searchParams]);

  useEffect(() => {
    actions['Armature.001Action'].reset().fadeIn(0.5).play().paused = true
    actions["ArmatureAction"].reset().fadeIn(0.5).play().paused = true
  }, [])

  useEffect(() => {
    console.log(props.scroll.current.toFixed(1), "sc")
    brain_material_controls.start(props.scroll.current > 0.1 ? "exit" : "enter")
    hand1_controls.start(props.scroll.current > 0.15 ? "enter" : "exit")
  }, [props.scroll.current])



  useFrame((state) => {
    actions['Armature.001Action'].time = lerp(actions['Armature.001Action'].time, actions['Armature.001Action'].getClip().duration * props.scroll.current, 0.025)
    actions["ArmatureAction"].time = lerp(actions["ArmatureAction"].time, actions["ArmatureAction"].getClip().duration * props.scroll.current, 0.025)
    glassMat.current.roughness = lerp(glassMat.current.roughness, searchParams.get("view") ? 1 : 0, 0.5);
    glassMat.current.opacity = lerp(glassMat.current.opacity, searchParams.get("view") ? 0.1 : router.pathname !== "/" || searchParams.get("test") !== null ? 0 : 1,
      router.pathname !== "/" || searchParams.get("test") !== null ? 0.03 : 0.05);
    // if (searchParams.get("test") === null) { bmRef.current.opacity = lerp(bmRef.current.opacity, props.scroll.current > 0.1 ? 0 : 1, 0.5) }
    // bmRef.current.opacity = lerp(glassMat.current.opacity, searchParams.get("view") ? 0.1 : router.pathname !== "/" || searchParams.get("test") !== null ? 0 : 1,
    //   router.pathname !== "/" || searchParams.get("test") !== null ? 0.03 : 0.05);
  })

  return (
    <group visible={!disposed} ref={group} {...props} dispose={null}>
      <group name="Scene" rotation={[0, Math.PI / 1.25, 0]} position={[0, -3.5, 0]}>
        <motion3d.group visible={!hand1Disposed} name="Armature" position={[1.543, 1.806, 1.657]} rotation={[-0.512, -1.029, 0.123]} scale={0.634}>
          <primitive object={nodes.Bone} />
          <primitive object={nodes.Bone003} />
          <primitive object={nodes.Bone006} />
          <primitive object={nodes.Bone009} />
          <primitive object={nodes.Bone012} />
          <skinnedMesh name="Cube" geometry={nodes.Cube.geometry} skeleton={nodes.Cube.skeleton} >{hand1Material}</skinnedMesh>
        </motion3d.group>
        <motion3d.group visible={!hand2Disposed} name="Armature001" position={[-1.255, 2.806, 1.699]} rotation={[Math.PI / 2, 0, -1.613]} scale={-0.634}>
          <primitive object={nodes.Bone_1} />
          <primitive object={nodes.Bone003_1} />
          <primitive object={nodes.Bone006_1} />
          <primitive object={nodes.Bone009_1} />
          <primitive object={nodes.Bone012_1} />
          <skinnedMesh name="Cube001" geometry={nodes.Cube001.geometry} skeleton={nodes.Cube001.skeleton} >{hand2Material}</skinnedMesh>
        </motion3d.group>
        <motion3d.mesh
          ref={brain}
          renderOrder={4}
          geometry={nodes.Cube002.geometry}
          position={[0, -1.2, -0]}
          visible={!brainDisposed}
        >
          {brain_material}
        </motion3d.mesh>
        <motion3d.mesh
          renderOrder={5}
          geometry={nodes.female_head001.geometry}
          position={[0.2, 0.2, -0.45]}
          visible={!headDisposed}
        >
          {glass}
        </motion3d.mesh>
        <IdeaCloud centerPoint={[0, 3, 0]} />

      </group>
    </group>
  )
}

useGLTF.preload('/handsNhead.glb')

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 public/neurons.glb --types --output src/Neurons.tsx 
*/

import * as THREE from 'three'
import React, { MutableRefObject, useEffect, useLayoutEffect, useRef, useState } from 'react'
import { useGLTF, useAnimations, Float } from '@react-three/drei'
import { GLTF } from 'three-stdlib'
import { useFrame } from '@react-three/fiber'
import { useAnimation } from 'framer-motion'
import { useAtom } from 'jotai'
import { lerp } from 'three/src/math/MathUtils.js'
import { loc } from './ts/atoms'
import { motion as motion3d } from "framer-motion-3d"
import { useSearchParams } from 'next/navigation'
import { useRouter } from 'next/router'

type GLTFResult = GLTF & {
  nodes: {
    Icosphere: THREE.Mesh
    Icosphere001: THREE.Mesh
    Icosphere002: THREE.Mesh
    Icosphere003: THREE.Mesh
    Icosphere004: THREE.Mesh
  }
  materials: {}
  animations: GLTFAction[]
}

type ActionName = 'IcosphereAction.005' | 'Key.001Action.004' | 'Icosphere.001Action' | 'KeyAction.004' | 'Icosphere.002Action' | 'Key.002Action.003' | 'Icosphere.003Action' | 'Key.003Action.003' | 'Icosphere.004Action' | 'Key.004Action.003'
interface GLTFAction extends THREE.AnimationClip {
  name: ActionName
}
type ContextType = Record<string, React.ForwardRefExoticComponent<JSX.IntrinsicElements['mesh']>>

type NeuronsProps = {
  scroll: MutableRefObject<number>;
  props?: JSX.IntrinsicElements['group']
}

const materialVariants = {
  initial: { opacity: 0 },
  enter: {
    opacity: 1,
    transition: {
      type: "spring",
      damping: 10,
      stiffness: 50,
      restDelta: 0.1,
    }
  },
  exit: {
    opacity: 0, roughness: 1, transition: {
      type: "spring",
      damping: 10,
      stiffness: 50,
      restDelta: 0.1, delay: 0.25
    }
  },
};

export function Neurons(props: NeuronsProps) {
  const group: any = useRef<THREE.Group>()
  const { nodes, materials, animations, userData, scene }: any = useGLTF('/neurons.glb') as GLTFResult
  const { actions }: any = useAnimations(animations, group)
  //atoms
  const [location, setLocation] = useAtom(loc)
  // controls
  const neuronMaterialControls = useAnimation();
  useEffect(() => {
    Object.values(actions).map((animation: any) => {
      animation.reset().fadeIn(0.5).play().paused = true
    })
    console.log(nodes, userData, scene)
  }, [])
  // router
  const router = useRouter()
  // search params
  const searchParams = useSearchParams();
  // mount states
  const [isInPage, setIsInPage] = useState(false);
  const [disposed, setDisposed] = useState(false);

  //render loop
  useFrame((state) => {
    Object.values(actions).map((animation: any) => {
      animation.time = lerp(animation.time, animation.getClip().duration * props.scroll.current * 5, 0.02)
    });
  });

  //uef
  useEffect(() => {
    if (
      location === "science" && router.pathname === "/" && searchParams.get("test") === null || false) {
      setDisposed(false), setIsInPage(true);
    } else {
      neuronMaterialControls.start("exit").then(() => {
        setTimeout(() => {
          setDisposed(true),
            setIsInPage(false);
        }, 500)
      })
    }
  }, [router.pathname, searchParams, location])

  useEffect(() => {
    isInPage && neuronMaterialControls.start("enter")
  }, [isInPage]);

  const ref1: any = useRef();
  const ref2: any = useRef();
  const ref3: any = useRef();
  const ref4: any = useRef();
  const ref5: any = useRef();

  useLayoutEffect(() => {
    ref1.current?.updateMorphTargets();
    ref2.current?.updateMorphTargets();
    ref3.current?.updateMorphTargets();
    ref4.current?.updateMorphTargets();
    ref5.current?.updateMorphTargets();
  }, []);


  // materials
  const neuronMaterial = <motion3d.meshStandardMaterial
    transparent
    color={"#ebf0d9"}
    initial="initial"
    animate={neuronMaterialControls}
    exit="exit"
    variants={materialVariants}
  />

  return (
    <Float visible={!disposed} rotationIntensity={0.1} floatIntensity={0.2} floatingRange={[-0.2, 0.2]}>
      <group visible={!disposed} ref={group} rotation={[Math.PI / 2, -Math.PI / 2, 0]} scale={10} position={[-130, 20, 0]} {...props} dispose={null}>
        <group name="Scene" >
          <mesh ref={ref1} name="Icosphere" geometry={nodes.Icosphere.geometry} position={[1.435, -8.934, -14.408]} >{neuronMaterial}</mesh>
          <mesh ref={ref2} name="Icosphere001" geometry={nodes.Icosphere001.geometry} position={[0.243, -7.793, -9.893]} rotation={[0.258, 0, 0]} >{neuronMaterial}</mesh>
          <mesh ref={ref3} name="Icosphere002" geometry={nodes.Icosphere002.geometry} position={[4.794, -8.791, -16.281]} >{neuronMaterial}</mesh>
          <mesh ref={ref4} name="Icosphere003" geometry={nodes.Icosphere003.geometry} position={[4.202, -10.807, -10.533]} >{neuronMaterial}</mesh>
          <mesh ref={ref5} name="Icosphere004" geometry={nodes.Icosphere004.geometry} position={[4.336, -8.531, -8.289]} >{neuronMaterial}</mesh>
        </group>
      </group>
    </Float>
  )
}

useGLTF.preload('/neurons.glb')

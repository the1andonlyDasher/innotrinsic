/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 public/neuron.glb --types --output src/neuron.tsx 
*/

import React, { useRef, useState } from 'react'
import { Bvh, Instance, Instances, useGLTF } from '@react-three/drei'
import { GLTF } from 'three-stdlib'
import { useFrame } from '@react-three/fiber'
import { AnimationClip } from 'three/src/animation/AnimationClip.js'
import { Group } from 'three/src/objects/Group.js'
import { SkinnedMesh } from 'three/src/objects/SkinnedMesh.js'
import { Bone } from 'three/src/objects/Bone.js'
import { Mesh } from 'three/src/objects/Mesh.js'
import { Color } from 'three/src/math/Color.js'
import { lerp } from '../threeExport/math/MathUtils'

type GLTFResult = GLTF & {
  nodes: {
    Icosphere: Mesh
  }
  materials: {}
  animations: any[]
}

type ContextType = Record<string, React.ForwardRefExoticComponent<JSX.IntrinsicElements['mesh']>>

export function Model(props: JSX.IntrinsicElements['group']) {
  const { nodes, materials } = useGLTF('/neuron.glb') as GLTFResult
  const randomVector = (r: any) => [r / 2 - Math.random() * r, r / 2 - Math.random() * r, r / 2 - Math.random() * r]
  const randomEuler = () => [Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI]
  const data = Array.from({ length: 200 }, (r = 10) => ({ random: Math.random(), position: randomVector(r), rotation: randomEuler() }))

  return (
    <Bvh firstHitOnly>
      <Instances limit={200} range={200} geometry={nodes.Icosphere.geometry} >
        <meshStandardMaterial />
        {data.map((props: any, i: number) =>
          <Neuron key={i} {...props} />)}
      </Instances>
    </Bvh>
  )
}

function Neuron({ random, color = new Color(), ...props }: any) {
  const ref = useRef<any>()
  const [hovered, setHover] = useState(false)
  useFrame((state) => {
    const t = state.clock.getElapsedTime() + random * 10000
    ref.current.rotation.set(Math.cos(t / 4) / 2, Math.sin(t / 4) / 2, Math.cos(t / 1.5) / 2)
    ref.current.position.y = Math.sin(t / 1.5) / 2
    ref.current.scale.x = ref.current.scale.y = ref.current.scale.z = lerp(ref.current.scale.z, hovered ? 1.4 : 1, 0.1)
    ref.current.color.lerp(color.set(hovered ? 'red' : 'blue'), hovered ? 1 : 0.1)
  })
  return (
    <group scale={0.2} {...props}>
      <Instance ref={ref} onPointerOver={(e) => (e.stopPropagation(), setHover(true))} onPointerOut={(e) => setHover(false)} />
    </group>
  )
}

useGLTF.preload('/neuron.glb')

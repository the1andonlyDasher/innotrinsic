/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 public/neuron.glb --types --output src/neuron.tsx 
*/

import * as THREE from 'three'
import React, { useRef, useState } from 'react'
import { Bvh, Instance, Instances, QuadraticBezierLine, useGLTF } from '@react-three/drei'
import { GLTF } from 'three-stdlib'
import { useFrame } from '@react-three/fiber'

type GLTFResult = GLTF & {
    nodes: {
        Icosphere: THREE.Mesh
    }
    materials: {}
    animations: any[]
}

type ContextType = Record<string, React.ForwardRefExoticComponent<JSX.IntrinsicElements['mesh']>>

export function NeuronNet(props: JSX.IntrinsicElements['group']) {
    const { nodes, materials } = useGLTF('/neuron.glb') as GLTFResult
    const randomVector = (r: any) => [r / 2 - Math.random() * r, r / 2 - Math.random() * r, r / 2 - Math.random() * r]
    const randomEuler = () => [Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI]
    const data = Array.from({ length: 200 })

    return (
        <Bvh firstHitOnly>
            <Instances limit={200} range={200} >
                <sphereGeometry args={[1, 30, 30]} />
                <meshStandardMaterial />
                {data.map((props: any, i: number) =>
                    <Neuron key={i} {...props} />)}
            </Instances>
        </Bvh>
    )
}

function Neuron({ random, color = new THREE.Color(), point2, point1, ...props }: any) {
    const center = useRef<any>()
    const left = useRef<any>()
    const right = useRef<any>()
    const down = useRef<any>()
    const up = useRef<any>()
    const line = useRef<any>()
    const [hovered, setHover] = useState(false)
    useFrame((state) => {
        // const t = state.clock.getElapsedTime() + random * 10000
        // ref.current.rotation.set(Math.cos(t / 4) / 2, Math.sin(t / 4) / 2, Math.cos(t / 1.5) / 2)
        // ref.current.position.y = Math.sin(t / 1.5) / 2
        // ref.current.scale.x = ref.current.scale.y = ref.current.scale.z = THREE.MathUtils.lerp(ref.current.scale.z, hovered ? 1.4 : 1, 0.1)
        // ref.current.color.lerp(color.set(hovered ? 'red' : 'turquoise'), hovered ? 1 : 0.1)
        line.current.setPoints(center.current.position, left.current.position)
    })
    return (
        <group scale={0.2} {...props} position={[0, 0, -10]}>
            <QuadraticBezierLine ref={line} start={[0, 0, 0]} end={[1, 1, 1]} />
            <Instance scale={0.5} position={[2, 2, 2]} ref={left} onPointerOver={(e) => (e.stopPropagation(), setHover(true))} onPointerOut={(e) => setHover(false)} />
            <Instance scale={0.5} position={[-2, -2, 2]} ref={right} onPointerOver={(e) => (e.stopPropagation(), setHover(true))} onPointerOut={(e) => setHover(false)} />
            <Instance ref={center} onPointerOver={(e) => (e.stopPropagation(), setHover(true))} onPointerOut={(e) => setHover(false)} />
            <Instance scale={0.5} position={[-2, 2, -2]} ref={up} onPointerOver={(e) => (e.stopPropagation(), setHover(true))} onPointerOut={(e) => setHover(false)} />
            <Instance scale={0.5} position={[2, -2, -2]} ref={down} onPointerOver={(e) => (e.stopPropagation(), setHover(true))} onPointerOut={(e) => setHover(false)} />
        </group>
    )
}

useGLTF.preload('/neuron.glb')

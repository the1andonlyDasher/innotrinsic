/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 public/hands.glb --types --output src/Hands.tsx 
*/

import * as THREE from 'three'
import React, { MutableRefObject, useEffect, useRef, useState } from 'react'
import { useGLTF, useAnimations, Center, Bounds } from '@react-three/drei'
import { GLTF } from 'three-stdlib'
import { Object3DNode, useFrame, useThree } from '@react-three/fiber'
import { lerp } from './ts/threeExport/math/MathUtils'
import { useAnimation } from 'framer-motion'
import { motion as motion3d } from "framer-motion-3d"
import { size } from './ts/utils'
import { useRouter } from 'next/router'
import { useSearchParams } from 'next/navigation'

type GLTFResult = GLTF & {
  nodes: {
    Cube: THREE.SkinnedMesh
    Cube001: THREE.SkinnedMesh
    Bone: THREE.Bone
    Bone003: THREE.Bone
    Bone006: THREE.Bone
    Bone009: THREE.Bone
    Bone012: THREE.Bone
    Bone_1: THREE.Bone
    Bone003_1: THREE.Bone
    Bone006_1: THREE.Bone
    Bone009_1: THREE.Bone
    Bone012_1: THREE.Bone
  }
  materials: {}
  animations: GLTFAction[]
}

type ActionName = 'ArmatureAction' | 'Armature.001Action'
interface GLTFAction extends THREE.AnimationClip {
  name: ActionName
}
type ContextType = Record<string, React.ForwardRefExoticComponent<JSX.IntrinsicElements['skinnedMesh'] | JSX.IntrinsicElements['bone']>>

type HandsType = {
  props?: JSX.IntrinsicElements['group'];
  scroll: MutableRefObject<number>;
}

const material2Variants = {
  initial: { opacity: 0 },
  hide: { opacity: 0.1 },
  enter: {
    opacity: 1,
    transition: {
      type: "spring",
      damping: 10,
      stiffness: 50,
      restDelta: 0.1,
    }
  },
  exit: {
    opacity: 0, transition: {
      type: "spring",
      damping: 10,
      stiffness: 50,
      restDelta: 0.1, delay: 0.25
    }
  },
};



export function Model_Hands(props: HandsType) {
  const { viewport } = useThree();
  useEffect(() => {
    console.log(props.scroll)
  }, [props.scroll]);
  const group = useRef<THREE.Group | any>()
  const { nodes, materials, animations } = useGLTF('/hands.glb') as GLTFResult
  const { actions }: any = useAnimations(animations, group)
  useEffect(() => {
    actions['Armature.001Action'].reset().fadeIn(0.5).play().paused = true
    actions["ArmatureAction"].reset().fadeIn(0.5).play().paused = true
  }, [])

  useFrame((state) => {
    console.log(props.scroll.current)
    actions['Armature.001Action'].time = lerp(actions['Armature.001Action'].time, actions['Armature.001Action'].getClip().duration * props.scroll.current, 0.025)
    actions["ArmatureAction"].time = lerp(actions["ArmatureAction"].time, actions["ArmatureAction"].getClip().duration * props.scroll.current, 0.025)
  })

  const handVariants = {
    initial: { scale: 0, y: -10, rotateX: 1, rotateY: -1.5 },
    enter: { rotateX: 1, rotateY: -1.5, scale: 1, y: 0, transition: { type: "spring", stiffness: 50, damping: 20, restDelta: 0.001, delay: 1 } },
    exit: { rotateX: 1, rotateY: -1.5, scale: 0, y: -10, transition: { type: "spring", stiffness: 50, damping: 20, restDelta: 0.001, } },
  }

  const controls = useAnimation();
  const handControls = useAnimation();

  //searchParams
  const searchParams = useSearchParams();

  //router
  const router = useRouter();

  // states
  const [disposed, setDisposed] = useState(false);
  const [isInPage, setIsInPage] = useState(false);



  useEffect(() => {
    if (isInPage) {
      controls.start("enter")
      handControls.start("enter")
    }
  }, [isInPage]);

  //searchParams
  useEffect(() => {

    if (searchParams.get("test") !== null) {
      setTimeout(() => {
        setDisposed(false);
        setIsInPage(true);
      }, 100);
    } else {
      setTimeout(() => {
        handControls.start("exit")
        controls.start("exit").then(() => {

          setIsInPage(false), setDisposed(true);

        });
      }, 10)

    }
  }, [searchParams]);

  const handMaterial = (
    <motion3d.meshStandardMaterial
      initial="initial"
      animate={controls}
      exit="exit"
      variants={material2Variants}
      color="#EDDFAB"
      transparent
      toneMapped
    />
  );

  return (
    // <Bounds fit clip margin={1.2}>
    <motion3d.group variants={handVariants} animate={handControls} ref={group} visible={!disposed} dispose={null}>
      <group name="Scene">
        <group name="Armature" position={[-1.255, 1.806, -1.545]} rotation={[-Math.PI / 2, 0, Math.PI / 2]} scale={0.634}>
          <primitive object={nodes.Bone} />
          <primitive object={nodes.Bone003} />
          <primitive object={nodes.Bone006} />
          <primitive object={nodes.Bone009} />
          <primitive object={nodes.Bone012} />
          <skinnedMesh name="Cube" geometry={nodes.Cube.geometry} skeleton={nodes.Cube.skeleton} >{handMaterial}</skinnedMesh>
        </group>
        <group name="Armature001" position={[-1.255, 1.806, 1.699]} rotation={[Math.PI / 2, 0, -Math.PI / 2]} scale={-0.634}>
          <primitive object={nodes.Bone_1} />
          <primitive object={nodes.Bone003_1} />
          <primitive object={nodes.Bone006_1} />
          <primitive object={nodes.Bone009_1} />
          <primitive object={nodes.Bone012_1} />
          <skinnedMesh name="Cube001" geometry={nodes.Cube001.geometry} skeleton={nodes.Cube001.skeleton} >{handMaterial}</skinnedMesh>
        </group>
      </group>
    </motion3d.group>
    // </Bounds>
  )
}

useGLTF.preload('/hands.glb')
